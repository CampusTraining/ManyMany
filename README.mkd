ManyMany
====

A Yii app for experimenting with complex grid views
----

The app shows four ways of implementing the loading of related data in a gridview.

All gridviews have working implementations of paging, sorting and filtering.

1. **[UseCase One](#usecase-one---lazy-loading)**: Only primary data is loaded with the `CActiveDataProvider`, related data is Lazy loaded.
2. **[UseCase Two](#usecase-two---group_concat)**: Related data is loaded using a GROUP_CONCAT query. This is the most data efficient way, but you can't do any manipulation using the join-model or related-model.
3. **UseCase Three**: You normally can't use Yii's Eager Loading method in gridviews in combination with a pager. (If you don't use the pager, you can Eager load without problems.)   
 The reason why it won't work with the pager is because the pager adds LIMIT and OFFSET to the query, but those are static. In combination with JOIN statements, this becomes a problem. I made some changes to _CActiveFinder_ so the correct LIMIT and OFFSET numbers are calculated using two seperate COUNT queries. This will enable you to use Yii's Eager loading without any problems.
4. **UseCase Four - KeenLoading**: This method uses a custom `KeenActiveDataProvider`, which loads all related data in a Keen way using a seperate query.

With these four methods, it might be hard to choose which one to use. Here are some considerations:

1. **UseCase One**  
    Pro: Default Yii lazy loading  
    Con: A lot of queries(!)

2. **UseCase Two**  
    Pro: Most data efficient  
    Pro: Only one query  
    Con: No manipulation of data of the related Model(s)

3. **UseCase Three**  
    Pro: Default Yii eager loading  
    Neutral: Up to two extra COUNT queries. (For a max of three queries)  
    Con: Like all eager loading, this can become data inefficient

4. **KeenLoading**  
    Pro: Able to manipulate data of the related Model(s)  
    Pro: Still very efficient  
    Neutral: One extra query for loading the related Model(s)

---

### UseCase One - Lazy Loading

**Methods**
- models/Review::searchOne()
- controllers/ReviewController::actionCaseOne()
- views/review/caseOne
- views/review/_caseOneGrid

**Explenation**  
You group the primary keys of Review, and set together to true. You don't select any data from Genre, because then its lazy loaded for each row.  
Because you're grouping the primary keys, the database returns only one row for each primary Model. This is why the pager doesn't break even though you set `$criteria->together` to `true`.  
Additionally, make sure to set the relations in `$criteria->with` that are lazy loaded to `array('select'=>false)`. This is more efficient since you're loading this data in a lazy way, so you don't need it in the first `SELECT` that the `CActiveDataProvider` performs..  

### UseCase Two - GROUP_CONCAT

**Methods**
- models/Review::searchTwo()
- controllers/ReviewController::actionCaseTwo()
- views/review/caseTwo
- views/review/_caseTwoGrid

**Explenation**  
Same as the explenation of UseCase One. In addition:  
You set a `$criteria->select`, that selects a GROUP_CONCAT of the data from Genre. Don't forget to set the attributes of the main Model here or else those aren't loaded. Note that you don't have to include the primary keys in this select statement. Those are automatically added by Yii.  
An example:  
```php

$criteria->select = array(
    //You don't need to select primary keys, they are automatically added.
    'GROUP_CONCAT(genres.name ORDER BY genres.name SEPARATOR \', \') AS allGenres',
    't.review',
   );
```
3. *Review::search3()* - Using classMap you import a custom CActiveFinder that enhances the eager loading magic of Yii. Easiest, but the disadvantage is that is does another 2 COUNT queries for the pager to work.
4. *Song::search()* - Related data is loaded in a keen fashion. Using KeenActiveDataProvider, the related models are loaded in a seperate query and then put into the relation properties of the earlier loaded models.
